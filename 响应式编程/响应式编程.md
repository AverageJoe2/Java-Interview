# 一、函数式编程和lambda表达式

## 1.1 基础知识

1、函数式编程

2、函数接口：只有一个要实现的方法的接口（可以有默认方法）

3、lambda表达式就是返回一个指定对象接口的实例

4、`@FunctionalInterface`是函数接口的标识

5、jdk8中的接口可以有默认的方法实现

6、接口多重继承时，默认方法的覆盖问题

```java
interface Interface1{
    default int add(int x,int y){
        return x + y;
    }
}
interface Interface2{
    default int add(int x,int y){
        return x + y;
    }
}
interface Interface3 extends Interface2,Interface1{

    @Override
    default int add(int x, int y) {
        return Interface1.super.add(x,y);
    }
}
```

7、函数接口

![](http://mycsdnblog.work/202020161126-v.png)

**Function<T,R>** 

```java
package com.example.lambda;


import java.text.DecimalFormat;
import java.util.function.Function;

interface MoneyFormat{
    String format(int i);
}

class MyMoney{
    private final int money;

    MyMoney(int money) {
        this.money = money;
    }

    public void printMoney(MoneyFormat format){
        System.out.println("存款为：" + format.format(money));
    }

    public void printMoney2(Function<Integer,String> format){
        System.out.println("存款为：" + format.apply(money));
    }
}

public class FunctionTest {
    public static void main(String[] args) {
        MyMoney money = new MyMoney(10000);

        money.printMoney(x -> new DecimalFormat("#,###").format(x));

        Function<Integer,String> function = x -> new DecimalFormat("#,###").format(x);
        money.printMoney2(function.andThen(s -> "人民币" + s));
    }
}
```

**Predicate和Consumer**

```java
		//1.断言
        Predicate<Integer> predicate = x -> x < 0;
        System.out.println(predicate.test(-3));
        //2.消费者
        Consumer<String> consumer = System.out::println;
        consumer.accept("123123");
```

8、方法引用

**jdk会默认把当前实例传入到非静态方法当中，参数名为this，位置是第一个参数:int(Dog this,int count)**

```java
package com.example.lambda;

import java.util.function.*;

class Dog{
    private String name;

    private Integer food = 10;

    Dog(){

    }
    Dog(String name) {
        this.name = name;
    }

    static void bark(Dog dog){
        System.out.println(dog + ":汪汪汪");
    }

    int eat(int count){
        this.food -= count;
        System.out.println("吃了：" + count + "斤");
        return this.food;
    }

    @Override
    public String toString() {
        return name;
    }
}

public class MethodRefrenceDemo {

    public static void main(String[] args) {
        Consumer<String> consumer = System.out::println;
        consumer.accept("123");
        //方法引用的形式

        //1.静态方法：类名::方法名
        Consumer<Dog> dogConsumer = Dog::bark;
        dogConsumer.accept(new Dog("哮天犬"));
        //2.非静态方法：对象名::方法名
        Dog dog = new Dog("哈士奇");
        Function<Integer,Integer> function = dog::eat;
        UnaryOperator<Integer> unaryOperator = dog::eat;
        System.out.println("还剩：" + function.apply(5) + "斤");
        System.out.println("还剩：" + unaryOperator.apply(5) + "斤");
        //3.非静态方法：类名::方法名  默认this参数，再加上实际参数
        BiFunction<Dog,Integer,Integer> eatFunction = Dog::eat;
        System.out.println("还剩：" + eatFunction.apply(dog,5) + "斤");
        //4.带参数的构造函数的方法引用：类名::new，关键在于分析参数和返回值
        Function<String,Dog> constructed = Dog::new;
        System.out.println(constructed.apply("柯基"));
        //5.无参构造函数的方法引用：类名::new，关键在于分析参数和返回值
        Supplier<Dog> supplier = Dog::new;
        System.out.println(supplier.get());
    }
}
```

9、类型推断

```java
package com.example.lambda;


interface MyCompute{
    int add(int x,int y);
}

interface MyCompute2{
    int add(int x,int y);
}

public class TypeDemo {

    public static void main(String[] args) {
        //1.变量类型定义
        MyCompute myCompute = (x,y)-> x + y;
        MyCompute[] myComputes = {(x,y)-> x + y};
        //2.强制转换
        Object lambda = (MyCompute)(x,y)-> x + y;
        //3.返回类型
        MyCompute lambda2 = TypeDemo.createLambda();
        //4.参数类型
        TypeDemo typeDemo = new TypeDemo();
        //typeDemo.test((x,y)-> x + y);
        //5.方法重载，需要进行强制转换
        typeDemo.test((MyCompute2)(x,y)-> x + y);
    }

    private void test(MyCompute o) {
    }

    private void test(MyCompute2 o) {
    }

    private static MyCompute createLambda() {
        return (x,y)-> x + y;
    }
}
```

10、变量引用

**匿名类引用外部变量时外部变量必须定义为final类型**

```java
package com.example.lambda;

import java.util.function.Consumer;

public class VarDemo {

    public static void main(String[] args) {
        final String s1 = "123";
        Consumer<String> consumer = x -> System.out.println("字符串为：" + x + s1);
        consumer.accept("456");
    }
}
```

jdk8中的final可以省略，**但是在lambda表达式内部引用的变量相当于是在匿名内部类中引用**，所以该变量在赋值后就不能修改。因为，在Java中参数的传递是值传递，当匿名内部类引用外部的参数时，其实在内部类中又创建了一个引用，指向该参数的内存地址；如果外部对此参数进行修改，那么就会导致内部类中的引用指向的对象与外面的不一致。**归根结底，是因为Java中的参数传递是值传递，不是引用传递**。

![](http://mycsdnblog.work/202020161313-e.png)

11、级联表达式和柯里化

```java
package com.example.lambda;

import java.util.function.Function;

/**
 * 级联表达式和柯里化
 * 柯里化：把含有多个参数的函数转换成只有一个参数的函数
 * 柯里化的目的就是把函数标准化了
 */
public class CurryDemo {

    public static void main(String[] args) {
        //实现了x+y
        Function<Integer,Function<Integer,Integer>> function = x ->y -> x + y;
        Integer res = function.apply(2).apply(3);
        System.out.println(res);
        Function<Integer,Function<Integer,Function<Integer,Integer>>> function1 = x -> y -> z -> x + y + z;
        Integer integer = function1.apply(2).apply(3).apply(4);
        System.out.println(integer);

        int[] nums = new int[]{100,200,300};
        Function f1 = function1;
        for (int s : nums){
            Object o = f1.apply(s);
            if (o instanceof Function) {
                f1 = (Function) o;
            } else {
                System.out.println("调用结束，结果为：" + Integer.valueOf(o.toString()));
            }
        }
    }
}
```

## 1.2 底层原理

1、编写一个函数接口并调用

```java
package com.example.lambda;

/**
 * @Author: 98050
 * @Time: 2020-06-16 14:07
 * @Feature:
 */

@FunctionalInterface
interface Calculation{
    int add(int x,int y);
}

public class Lambda {

    public static void test(int a, int b, Calculation calculation){
        System.out.println(calculation.add(a,b));
    }

    public static void main(String[] args) {
        test(1,2,(a,b) -> a + b);
    }
}
```

2、使用javap反编译

![](http://mycsdnblog.work/202020161445-y.png)

由上面的代码可以看出编译器会根据Lambda表达式生成一个私有的静态函数，注意，在这里说的是生成，而不是等价 。为了验证其转化的正确性，我们新增一个方法，名字为`lambda$main$0`

![](http://mycsdnblog.work/202020161448-L.png)

然后运行：

![](http://mycsdnblog.work/202020161448-e.png)

 Lambda表达式在Java 8中首先会生成一个私有的静态函数，这个私有的静态函数干的就是Lambda表达式里面的内容,因此上面的代码初步可以转化成如下所示的代码 ：

```java
package com.example.lambda;

/**
 * @Author: 98050
 * @Time: 2020-06-16 14:07
 * @Feature:
 */

@FunctionalInterface
interface Calculation{
    int add(int x,int y);
}

public class Lambda {

    public static void test(int a, int b, Calculation calculation){
        System.out.println(calculation.add(a,b));
    }

    private static int lambda$main$0(int a, int b){
        return a + b;
    }

    public static void main(String[] args) {
        test(1,2,/*lambda 表达式*/);
    }
}
```

转化成上面的形式之后，那么如何实现调用静态的`lambda$main$0`函数呢？可以在运行时加上

-Djdk.internal.lambda.dumpProxyClasses，加上这个参数后运行时会将生成的内部类class码输出到一个文件中 

```shell
java -Djdk.internal.lambda.dumpProxyClasses Lambda
```

![](http://mycsdnblog.work/202020161513-g.png)

对`Lambda$$Lambda$1.class`进行反编译

![](http://mycsdnblog.work/202020161519-h.png)

可以发现实现上调用的是`Lambda.lambda$main$0`这个私有的静态方法 

3、最终代码

```java
package com.example.lambda;


/**
 * @Author: 98050
 * @Time: 2020-06-16 14:07
 * @Feature:
 */

@FunctionalInterface
interface Calculation{
    int add(int x,int y);
}

public class Lambda {

    public static void test(int a, int b, Calculation calculation){
        System.out.println(calculation.add(a,b));
    }

    private static int lambda$main$0(int a, int b){
        return a + b;
    }

    static final class Lambda$$Lambda$1 implements Calculation {
        private Lambda$$Lambda$1() {
        }

        @Override
        public int add(int var1, int var2) {
            return Lambda.lambda$main$0(var1, var2);
        }
    }

    public static void main(String[] args) {
        test(1,2,new Lambda$$Lambda$1());
    }
}
```

4、小结

- 在类编译时，会生成一个私有静态方法+一个内部类；
- 在内部类中实现了函数式接口，在实现接口的方法中，会调用编译器生成的静态方法
- 在使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法

**其实就是传递一个函数指针**

# 二、Stream流

## 2.1 中间操作和惰性求值

```java
package com.example.stream;

import java.util.stream.IntStream;

public class Demo1 {

    public static void main(String[] args) {
        int[] nums = new int[]{1,2,3,4,5,6};
        int sum = 0;
        for (int c : nums){
            sum += c;
        }
        System.out.println(sum);
        //调用sum()就是终止操作
        //map就是中间操作
        //不调用终止操作的话，中间操作是不会执行的-------->惰性求值。
        int sum1 = IntStream.of(nums).map(x -> x * 2).sum();
        System.out.println(sum1);

        //结论验证
        int sum2 = IntStream.of(nums).map(Demo1::multiply).sum();
        System.out.println(sum2);
        System.out.println("----------------------");
        IntStream.of(nums).map(Demo1::multiply);
    }

    public static int multiply(int x){
        System.out.println("调用乘积函数");
        return x * 3;
    }
}
```

## 2.2 流的创建

![image-20200218205702799](http://mycsdnblog.work/202020161318-8.png)

```java
package com.example.stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Demo2 {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();

        //从集合创建普通流和并行流
        list.stream();
        list.parallelStream();

        //从数组创建流
        Arrays.stream(new int[]{1,2,3,4});

        //创建数字流
        IntStream.of(1,2,3,4);
        IntStream.rangeClosed(1,10);

        //使用random创建流
        IntStream limit = new Random().ints().limit(100);

        //自己创建流
        Stream.generate(() -> IntStream.of(1,2,3,4));
    }
}
```

## 2.3 中间操作

![image-20200218212609162](http://mycsdnblog.work/202020161749-h.png)

无状态：与前后元素没有关系

有状态：依赖于前后的元素

```java
package com.example.stream;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class Demo3 {

    public static void main(String[] args) {
        String string = "ads das das das das ddas";
        for (String s : string.split(" ")){
            System.out.println(s);
        }
        Stream.of(string.split(" ")).map(s -> s.length()).forEach(System.out::println);

        //flatMap的作用：A的B属性是个集合，将所有A的B属性
        //A中每个元素是字符串，每个字符串都可以转换成字符数组，是个集合，最后得到A中所有字符串中的字符。
        //IntStream/LongStream并不是Stream的子类，操作的时候需要使用boxed()进行装箱
        Stream.of(string.split(" ")).flatMap(s -> s.chars().boxed()).forEach(c -> System.out.println((char)c.intValue()));

        //peek是中间操作，相当于debug，查看流内部的工作情况，forEach是终止操作
        Stream.of(string.split(" ")).peek(System.out::println).forEach(System.out::println);

        //limit主要用于无限流
        new Random().ints().limit(10).forEach(System.out::println);
        new Random().ints().filter(x -> x > 100 && x < 1000).limit(10).forEach(System.out::println);
        new Random().ints(1,10).limit(10).forEach(System.out::println);
        System.out.println("--------------------------");

        String s2 = "123";
        IntStream chars = s2.chars();
        Stream<Integer> boxed = chars.boxed();
        boxed.forEach(System.out::println);
        LongStream.of(1,2,3,4,5).forEach(System.out::println);
    }
}
```

## 2.4 终止操作

![image-20200218222903696](http://mycsdnblog.work/202020161327-S.png)

短路操作：不用等待所有的结果计算完成，只要找到符合条件的就可以返回结果

**allMatch和noneMatch怎么理解?**

```java
package com.example.stream;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Demo4 {

    public static void main(String[] args) {
        String s1 = "my name is lily";
        //1.创建并行流
        s1.chars().parallel().forEach(c -> System.out.println((char)c));
        //2.使用forEachOrdered，保证顺序
        s1.chars().parallel().forEachOrdered(c -> System.out.println((char)c));


        //3.收集成list
        List<String> collect = Stream.of(s1.split(" ")).collect(Collectors.toList());
        System.out.println(collect);
        //4.转换成数组
        Object[] objects = Stream.of(s1.split(" ")).toArray();
        for (Object o : objects){
            System.out.println(o.toString());
        }
        //5.使用reduce来拼接字符串
        Optional<String> reduce = Stream.of(s1.split(" ")).reduce((x, y) -> x + "|" + y);
        System.out.println(reduce.get());
        //6.带初值的reduce
        String reduce1 = Stream.of(s1.split(" ")).reduce("", (x, y) -> x + "|" + y);
        System.out.println(reduce1);
        //6.求所有单词的长度和
        Integer reduce2 = Stream.of(s1.split(" ")).map(String::length).reduce(0, (a, b) -> a + b);
        System.out.println(reduce2);
        //7.min\max\count
        Optional<String> max = Stream.of(s1.split(" ")).max((a,b) -> a.length() - b.length());
        Optional<String> min = Stream.of(s1.split(" ")).min((a,b) -> a.length() - b.length());
        System.out.println(max.get());
        System.out.println(min.get());
        long count = Stream.of(s1.split(" ")).count();
        System.out.println(count);

        //8.findAny短路操作
        //可以看到findAny()操作，返回的元素是不确定的，对于同一个列表多次调用findAny()有可能会返回不同的值。
        // 使用findAny()是为了更高效的性能。如果是数据较少，串行地情况下，一般会返回第一个结果，如果是并行的情况，那就不能确保是第一个。
        Optional<String> any = Stream.of(s1.split(" ")).parallel().findAny();
        System.out.println(any.get());
        //9.findFirst短路操作
        Optional<String> first = Stream.of(s1.split(" ")).findFirst();
        System.out.println(first.get());

        //10.allMatch
        boolean b = Stream.of(s1.split(" ")).allMatch(s -> s.length() >= 2);
        System.out.println(b);
        //11.anyMatch
        boolean b1 = Stream.of(s1.split(" ")).anyMatch(s -> s.length() > 3);
        System.out.println(b1);
        //12.nonMatch
        boolean b2 = Stream.of(s1.split(" ")).noneMatch(s -> s.length() > 5);
        System.out.println(b2);

    }
}
```

## 2.5 并行流

1、创建并行流

2、同时调用串行和并行，以最后一次调用为准

3、并行流默认使用`ForkJoinPool`线程池

4、使用自定义`ForkJoinPool`线程池完成并行操作

```java
package com.example.stream;

import java.util.concurrent.ForkJoinPool;
import java.util.stream.IntStream;

public class Demo5 {

    public static void main(String[] args) {
        //1.创建并行流
        //IntStream.range(1,100).parallel().peek(Demo5::debug).count();
        //2.同时调用串行和并行，以最后一次调用为准
        //IntStream.range(1,100).parallel().peek(Demo5::debug).sequential().count();
        //3.并行流使用的线程池:ForkJoinPool.commonPool,默认线程数是当前机器的CPU数，
        // 通过System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","20");来修改默认线程数
        //System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","20");
        //IntStream.range(1,100).parallel().peek(Demo5::debug).count();
        //4.使用自己的线程池，防止提交的任务阻塞ForkJoinPool-1
        ForkJoinPool forkJoinPool = new ForkJoinPool(10);
        forkJoinPool.submit(() -> {
            IntStream.range(1,100).parallel().peek(Demo5::debug).count();
        });
        forkJoinPool.shutdown();

        synchronized (forkJoinPool){
            try {
                forkJoinPool.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void debug(int i){
        System.out.println(Thread.currentThread().getName() + "debug" + i);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## 2.7 收集器Collectors

收集器比较常用的几个方法：收集后的结果放入集合中、数据的汇总信息、数据分块、数据分组

```java
package com.example.stream;

import java.util.Arrays;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Demo6 {

    enum Gender{
        MALE(1),
        FEMALE(0);
        int tag;

        Gender(int tag) {
            this.tag = tag;
        }
    }

    enum Grade{
        ONE(1),
        TWO(2),
        THREE(3),
        FOUR(4);
        int num;

        Grade(int num) {
            this.num = num;
        }
    }

    static class Student{
        /**
         * 姓名
         */
        private String name;
        /**
         * 年龄
         */
        private int age;
        /**
         * 性别
         */
        private Gender gender;
        /**
         * 班级
         */
        private Grade grade;

        public Student(String name, int age, Gender gender, Grade grade) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.grade = grade;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public Gender getGender() {
            return gender;
        }

        public void setGender(Gender gender) {
            this.gender = gender;
        }

        public Grade getGrade() {
            return grade;
        }

        public void setGrade(Grade grade) {
            this.grade = grade;
        }

        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    ", gender=" + gender +
                    ", grade=" + grade +
                    '}';
        }
    }


    public static void main(String[] args) {
        List<Student> list = Arrays.asList(
                new Student("小明",11,Gender.MALE,Grade.ONE),
                new Student("小白",12,Gender.FEMALE,Grade.TWO),
                new Student("小黑",13,Gender.FEMALE,Grade.ONE),
                new Student("小红",10,Gender.MALE,Grade.THREE),
                new Student("小橙",8,Gender.FEMALE,Grade.ONE),
                new Student("小橘",9,Gender.MALE,Grade.ONE),
                new Student("小球",7,Gender.FEMALE,Grade.FOUR),
                new Student("大球",11,Gender.MALE,Grade.ONE)
        );

        //1.得到所有学生的年龄列表 stu -> stu.getAge() -----> Student::getAge()，不会产生lambda$0这样的函数，尽量使用方法引用
        List<Integer> ageList = list.stream().map(Student::getAge).collect(Collectors.toList());
        System.out.println(ageList);

        //2.得到年龄的汇总信息
        IntSummaryStatistics collect = list.stream().collect(Collectors.summarizingInt(Student::getAge));
        System.out.println(collect);

        //3.数据分块，根据年龄进行分块
        Map<Boolean, List<Student>> partitionByGender = list.stream().collect(Collectors.partitioningBy(stu -> stu.gender == Gender.MALE));
        System.out.println(partitionByGender);

        //4.数据分组，根据班级进行分组
        Map<Grade, List<Student>> groupByGrade = list.stream().collect(Collectors.groupingBy(Student::getGrade));
        System.out.println(groupByGrade);

        //5.数据分组，统计每个班有多少学生
        Map<Grade, Long> studentsOfGrade = list.stream().collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));
        System.out.println(studentsOfGrade);
    }
}
```

## 2.8 Stream的运行机制

```java
package com.example.stream;

import java.util.Random;
import java.util.stream.Stream;

public class Demo7 {
    /**
     * 1.所有的无状态操作都是链式调用的，一个元素迭代一次
     * 2.每一个无状态中间操作都会返回一个新的流。流里面有一个属性soureStage，指向调用链表的头Head。
     *   那么操作链表就是Head->nextStage(第一个中间操作)->nextStage(第二个中间操作)...->NULL
     * 3.有状态的中间操作会把无状态的中间操作截断，单独对有状态的中间操作进行处理
     * 4.当创建的是并行流时，有状态的中间操作不一定是并行处理的
     * 5.parallel()和sequential()是两个中间操作，也返回Stream，但是它们并不创建新的流，
     *   只是去修改Head即sourceStaeg中并行标志parallel，所以同时调用parallel()和sequential()
     *   只会以最后一次调用为准
     */

    public static void main(String[] args) {
        Random random = new Random();
        Stream<Integer> stream = Stream.generate(random::nextInt).limit(100)
                //第一个无状态操作
                .peek(s -> print("peek:" + s))
                //第二个无状态操作
                .filter(s -> {
                    print("filter:" + s);
                    return s > 10000;
                })
                //第一个有状态操作
                .sorted((a,b) -> {
                    print("排序：" + a + "," + b);
                    return a.compareTo(b);
                })
                //第三个无状态操作
                .peek(s -> print("peek2:" + s)).parallel();
        //终止操作
        stream.count();
    }

    private static void print(String s) {
        //System.out.println(s);
        System.out.println(Thread.currentThread().getName() + "->" + s);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## 2.9 深入理解Stream流水线

<img src="http://mycsdnblog.work/202020161752-T.png" alt="image-20200220162311608" style="zoom: 80%;" />

Stream采用某种方式记录用户每一步的操作，当用户调用终止操作时将之前记录的操作叠加到一起，尽可能地在一次迭代中全部执行掉，那么

1. 用户的操作如何记录？
2. 操作如何叠加？
3. 叠加后的操作如何执行？
4. 执行后的结果（如果有）在哪里？

### 2.9.1 操作如何记录

注意这里使用的是“*操作(operation)*”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是<*数据来源，操作，回调函数*>构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的*PipelineHelper*来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。与Stream相关类和接口的继承关系如下图：

![image-20200220180649456](http://mycsdnblog.work/202020161753-C.png)

Head用于表示第一个Stage，该Stage不包含任何操作
StatelessOp和StatefulOp分别表示无状态和有状态的Stage

![image-20200220181149711](http://mycsdnblog.work/202020161753-s.png)

使用`Collection.stream` `Arrays.stream`或`Stream.of`等接口会生成`Head`，其内部均采用`StreamSupport.stream`方法，将原始数据包装为`Spliterator`存放在Stage中

![image-20200220182341199](http://mycsdnblog.work/202020161753-n.png)

- Head记录Stream起始操作，将包装为Spliterator的原始数据存放在Stage中
- StatelessOp记录无状态的中间操作
- StatefulOp记录有状态的中间操作
- TerminalOp用于触发数据数据在各Stage间的流动及处理，并收集最终数据(如果有)

Head StatelessOp StatefulOp三个操作实例化会指向其父类AbstractPipeline

![image-20200220183457821](http://mycsdnblog.work/202020161754-f.png)

其会将包装为Spliterator的原始数据存放在Stage中，并将自身存放在sourceStage中

对于StatelessOp及StatefulOp

![image-20200220183525214](http://mycsdnblog.work/202020161754-m.png)

每一个Stage都会存放原始的sourceStage，即Head

通过previousStage及nextStage，将各Stage串联为一个双向链表，使得每一步都知道上一步与下一步的操作

### 2.9.2 操作如何叠加

以上已经解决了如何记录操作的问题，想要让pipeline运行起来，需要一种将所有操作叠加到一起的方案

由于前面的Stage并不知道后面的Stage到底需要执行何种操作，只有当前Stage本身知道该如何执行自己包含的动作，这就需要某种协议来协调相邻Stage之间的调用关系。

Stream类库采用了Sink接口来协调各Stage之间的关系，Sink接口包含的方法如下表所示：

| 方法名                          | 作用                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| void begin(long size)           | 开始遍历元素之前调用该方法，通知Sink做好准备。               |
| void end()                      | 所有元素遍历完成之后调用，通知Sink没有更多的元素了。         |
| boolean cancellationRequested() | 是否可以结束操作，可以让短路操作尽早结束。                   |
| void accept(T t)                | 遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。 |

有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的`accept()`方法即可，并不需要知道其内部是如何处理的。

**对于有状态的操作**，Sink的`begin()`和`end()`方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个乘放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。

**对于短路操作**，`Sink.cancellationRequested()`也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回*true*，以便调用者尽快结束查找。

Sink的四个接口方法常常相互协作，共同完成计算任务。**实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。**

有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。

下面结合具体源码来理解Stage是如何将自身的操作包装秤Sink，以及Sink是如何将处理结果转发给下一个Sink的

无状态Stage，Stream.map

```java
// Stream.map 将生成一个新Stream
public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {
    Objects.requireNonNull(mapper);
    return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
        // 该方法将回调函数(处理逻辑)包装成Sink
        @Override
        Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
            return new Sink.ChainedReference<P_OUT, R>(sink) {
                @Override
                public void accept(P_OUT u) {
                    // 接收数据，使用当前包装的回调函数处理数据，并传递给下游Sink
                    downstream.accept(mapper.apply(u));
                }
            };
        }
    };
}
```

上述代码看似复杂，其实逻辑很简单，就是将回调函数*mapper*包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。

有状态Stage，Stream.sorted

```java
private static final class RefSortingSink<T> extends AbstractRefSortingSink<T> {
    // 存放用于排序的元素
    private ArrayList<T> list;

    RefSortingSink(Sink<? super T> sink, Comparator<? super T> comparator) {
        super(sink, comparator);
    }

    @Override
    public void begin(long size) {
        if (size >= Nodes.MAX_ARRAY_SIZE)
            throw new IllegalArgumentException(Nodes.BAD_SIZE);
        // 创建用于存放排序元素的列表
        list = (size >= 0) ? new ArrayList<T>((int) size) : new ArrayList<T>();
    }

    @Override
    public void end() {
        // 只有在接收到所有元素后才开始排序
        list.sort(comparator);
        downstream.begin(list.size());
        // 排序完成后，将数据传递给下游Sink
        if (!cancellationWasRequested) {
            // 下游Sink不包含短路操作，将数据依次传递给下游Sink
            list.forEach(downstream::accept);
        }
        else {
            // 下游Sink包含短路操作
            for (T t : list) {
                // 对于每一个元素，都要询问是否可以结束处理
                if (downstream.cancellationRequested()) break;
                // 将元素传递给下游Sink
                downstream.accept(t);
            }
        }
        // 告知下游Sink数据传递完毕
        downstream.end();
        list = null;
    }

    @Override
    public void accept(T t) {
        // 依次将需要排序的元素加入到临时列表中
        list.add(t);
    }
}
```

上述代码完美的展现了Sink的四个接口方法是如何协同工作的：

1. 首先beging()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；
2. 之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；
3. 最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；
4. 如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。

Stream.sorted会在接收到所有元素之后再进行排序，在此之后才开始将数据依次传递给下游Sink

![image-20200220185459357](http://mycsdnblog.work/202020161756-N.png)

### 2.9.3 叠加的操作如何执行

Sink完美封装了Stream每一步操作，并给出了[处理->转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。

结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理->转发]模型，结束操作的Sink就是调用链的出口。

TerminalOp的类图非常简单：

![image-20200220195805797](http://mycsdnblog.work/202020161756-t.png)

FindOp: 用于查找，如`findFirst`，`findAny`，生成`FindSink`
ReduceOp: 用于规约，如`reduce` `collect`，生成`ReduceSink`
MatchOp: 用于匹配，如`allMatch` `anyMatch`，生成`MatchSink`
ForEachOp: 用于遍历，如`forEach`，生成`ForEachSink`

![image-20200220195953745](http://mycsdnblog.work/202020161756-H.png)

在调用Stream的终止操作时，会执行`AbstractPipeline.evaluate`

```java
// Terminal evaluation methods

    /**
     * Evaluate the pipeline with a terminal operation to produce a result.
     *
     * @param <R> the type of result
     * @param terminalOp the terminal operation to be applied to the pipeline.
     * @return the result
     */
    final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) {
        assert getOutputShape() == terminalOp.inputShape();
        if (linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        linkedOrConsumed = true;

        return isParallel()
               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }
```

以串行为例，接下来进入到`evaluateSequential`方法中：

```java
default <P_IN> R evaluateParallel(PipelineHelper<E_IN> helper,
                                  Spliterator<P_IN> spliterator) {
    if (Tripwire.ENABLED)
        Tripwire.trip(getClass(), "{0} triggering TerminalOp.evaluateParallel serial default");
    return evaluateSequential(helper, spliterator);
}
```

最终会根据是否并行执行TerminalOp中不同的的evaluate方法，在TerminalOp的evaluate方法中会调用`helper.wrapAndCopyInto(sinkSupplier.get(), spliterator).get()`来串联各层Sink，触发pipeline，并获取最终结果，那TerminalOp到底是如何串联各层Sink的？

```java
@Override
final <P_IN, S extends Sink<E_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator) {
    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
    return sink;
}
```

其中玄机尽在`warpSink`

![image-20200220200125694](http://mycsdnblog.work/202020161757-r.png)

我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在*PipelineHelper*中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个`Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)`方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：

```java
// AbstractPipeline.wrapSink()
// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，
// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。
final <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) {
    ...
    for (AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) {
        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
    }
    return (Sink<P_IN>) sink;
}
```

现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下，`wrapAndCopyInto`中的`copyInto`方法：

```java
final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
    Objects.requireNonNull(wrappedSink);

    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
        // 不包含短路操作
        
        // 1. begin
        wrappedSink.begin(spliterator.getExactSizeIfKnown());
        // 2. 遍历调用 sink.accept
        spliterator.forEachRemaining(wrappedSink);
        // 3. end
        wrappedSink.end();
    }
    else {
        // 包含短路操作
        copyIntoWithCancel(wrappedSink, spliterator);
    }
}

final <P_IN> void copyIntoWithCancel(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
    @SuppressWarnings({"rawtypes","unchecked"})
    AbstractPipeline p = AbstractPipeline.this;
    while (p.depth > 0) {
        p = p.previousStage;
    }
    // 1. begin
    wrappedSink.begin(spliterator.getExactSizeIfKnown());
    // 2. 遍历调用 sink.accept
    //    每一次遍历都询问cancellationRequested结果
    //    如果cancellationRequested为true，则中断遍历
    p.forEachWithCancel(spliterator, wrappedSink);
    // 3. end
    wrappedSink.end();
}
```

`copyInto`会根据不同的情况依次

1. 调用`sink.bigin`
2. 遍历调用`sink.accept`，如果包含短路操作，则每次遍历都需要询问`cancellationRequested`，适时中断遍历
3. 调用`sink.end`

上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。

### 2.9.4 最终的执行结果保存

各层Stage通过Sink协议将所有的操作串联到一起，遍历原始数据并执行，终止操作会创建一个包装了自己操作的TerminalSink，该Sink中处理最终的数据并做数据收集（如果需要），每一种TerminalSink中均会提供一个获取最终数据的方法。

![image-20200224163242575](http://mycsdnblog.work/202020161757-F.png)

TerminalOp通过调用TerminalSink中的对应方法，获取最终的数据并返回，如ReduceOp中：

```java
@Override
public <P_IN> R evaluateSequential(PipelineHelper<T> helper,
                                   Spliterator<P_IN> spliterator) {
    return helper.wrapAndCopyInto(makeSink(), spliterator)/* 执行各Sink */.get()/* 获取最终数据 */;
}
```

首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(*Side-effects*)，比如使用`Stream.forEach()`方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？

特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。

```java
// 错误的收集方式
ArrayList<String> results = new ArrayList<>();
stream.filter(s -> pattern.matcher(s).matches())
      .forEach(s -> results.add(s));  // Unnecessary use of side-effects!
// 正确的收集方式
List<String>results =
     stream.filter(s -> pattern.matcher(s).matches())
             .collect(Collectors.toList());  // No side-effects!
```

回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。

| 返回类型 | 对应的结束操作                    |
| -------- | --------------------------------- |
| boolean  | anyMatch() allMatch() noneMatch() |
| Optional | findFirst() findAny()             |
| 归约结果 | reduce() collect()                |
| 数组     | toArray()                         |

1. 对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。
2. 对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。
3. 对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做*Node*的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。

### 2.9.5 并发是如何做到的

使用`Collection.parallelStream`或`Stream.parallel`等方法可以将当前的流`标记`为并发，重新来看`AbstractPipeline.evaluate`，该方法会在终止操作时被执行

```java
    // Terminal evaluation methods

    /**
     * Evaluate the pipeline with a terminal operation to produce a result.
     *
     * @param <R> the type of result
     * @param terminalOp the terminal operation to be applied to the pipeline.
     * @return the result
     */
    final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) {
        assert getOutputShape() == terminalOp.inputShape();
        if (linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        linkedOrConsumed = true;

        return isParallel()
               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }
```

如果被标记为`sequential`，则会调用`TerminalOp.evaluateSequential`，evaluateSequential的调用过程上文已经讲述的很清楚了；如果被标记为`parallel`，则会调用`TerminalOp.evaluateParallel`，对于该方法不同的TerminalOp会有不同的实现，但都使用了ForkJoin框架，将原始数据不断拆分为更小的单元，对每一个单元做上述`evaluateSequential`类似的动作，最后将每一个单元计算的结果依次整合，得到最终结果。

![image-20200224163830014](http://mycsdnblog.work/202020161758-q.png)

默认情况下，ForkJoin的线程数即为机器的CPU核数，如果想自定义Stream并行执行的线程数，可以参考[Custom Thread Pools In Java 8 Parallel Streams](https://www.baeldung.com/java-8-parallel-streams-custom-threadpool)

在将原始数据进行拆分的时候，拆分的策略是什么？拆分的粒度又是什么(拆分到什么程度)？

还记得上文所说，原始数据是如何存放的么？`Spliterator`(可分迭代器 splitable iterator)，无论使用何种API，均会将原始数据封装为`Spliterator`后存放在Stage中，在进行parallel计算时，对原始数据的拆分以及拆分粒度都是基于`Spliterator`的，和Iterator一样，Spliterator也用于遍历数据源中的数据，但它是专门为并行执行而设计的。

```java
public interface Spliterator<T> {
    /**
     * 如果还有元素需要遍历，则遍历该元素并执行action，返回true，否则返回false
     */
    boolean tryAdvance(Consumer<? super T> action);
    
    /**
     * 如果可以，则将一部分元素划分出去，构造另一个Spliterator，使得两个Spliterator可以并行处理
     */
    Spliterator<T> trySplit();
    
    /**
     * 估算还有多少元素需要遍历
     */
    long estimateSize();
    
    /**
     * 遍历所有未遍历的元素
     */
    default void forEachRemaining(Consumer<? super T> action) {
        do { } while (tryAdvance(action));
    }
}
```

在使用Stream parallel时，如果默认Spliterator的拆分逻辑不能满足你的需求，便可以自定义Spliterator，具体示例可以参考《Java 8 in Action》中『7.3.2 实现你自己的Spliterator』

![image-20200224164052360](http://mycsdnblog.work/202020161759-G.png)

### 2.9.6 结论

1. `Head`会生成一个不包含任何操作的Stage，并将原始数据`Spliterator`存放在`sourceStage`中
2. 中间操作`StagelessOp` `StagefulOp`将当前操作封装在Sink中，生成一个新的Stage，并使用双链表结构将前后的Stage链接在一起，Sink用于调用当前指定的操作处理数据，并将处理后的结果传递给下游Sink
3. 终止操作`TerminalOp`生成一个`TerminalSink`，从下游向上游遍历Stage，不断包装各Stage中的Sink，最终生成一个串联了所有操作的TerminalSink，适时调用该Sink的`begin` `accept` `end`等方法，触发整个pipeline的数据流动及处理，最终调用TerminalSink的`get`方法，获取最终结果(如果有)
4. 被标记为parallel的流，会使用ForkJoin框架，将原始流拆分为更小的单元，对每一个单元分别作计算，并将各单元的计算结果进行整合，得到最终结果。

# 三、Reactive Stream

## 3.1 基本概念

Reactive Stream (响应式流/反应流) 是JDK9引入的一套标准，是一套基于发布/订阅模式的数据处理规范。响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。更确切地说，Reactive流目的是“找到最小的一组接口，方法和协议，用来描述必要的操作和实体以实现这样的目标：以非阻塞背压方式实现数据的异步流”。

“背压(反压)back pressure”概念很关键。首先异步消费者会向生产者订阅接收消息，然后当有新的信息可用时，消费者会通过之前订阅时提供的回调函数被再次激活调用。如果生产者发出的信息比消费者能够处理消息最大量还要多，消费者可能会被迫一直在抓消息，耗费越来越多的资源，埋下潜在的崩溃风险。为了防止这一点，需要有一种机制使消费者可以通知生产者，降低消息的生成速度。生产者可以采用多种策略来实现这一要求，这种机制称为背压。

响应式流模型非常简单——订阅者向发布者发送多个元素的异步请求，发布者向订阅者异步发送多个或稍少的元素。响应式流会在pull模型和push模型流处理机制之间动态切换。 当订阅者较慢时，它使用pull模型，当订阅者更快时使用push模型。

简单来说，在响应式流下订阅者可以与发布者沟通，如果使用JMS就应该知道，订阅者只能被动接收发布者所产生的消息数据。这就好比没有水龙头的水管一样，我只能被动接收水管里流过来的水，无法关闭也无法减少。而响应式流就相当于给水管加了个水龙头，在消费者这边可以控制水流的增加、减少及关闭。

响应式流模型图：

Reactive Stream (响应式流/反应流) 是JDK9引入的一套标准，是一套基于发布/订阅模式的数据处理规范。响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。更确切地说，Reactive流目的是“找到最小的一组接口，方法和协议，用来描述必要的操作和实体以实现这样的目标：以非阻塞背压方式实现数据的异步流”。

“背压(反压)back pressure”概念很关键。首先异步消费者会向生产者订阅接收消息，然后当有新的信息可用时，消费者会通过之前订阅时提供的回调函数被再次激活调用。如果生产者发出的信息比消费者能够处理消息最大量还要多，消费者可能会被迫一直在抓消息，耗费越来越多的资源，埋下潜在的崩溃风险。为了防止这一点，需要有一种机制使消费者可以通知生产者，降低消息的生成速度。生产者可以采用多种策略来实现这一要求，这种机制称为背压。

响应式流模型非常简单——订阅者向发布者发送多个元素的异步请求，发布者向订阅者异步发送多个或稍少的元素。响应式流会在pull模型和push模型流处理机制之间动态切换。 当订阅者较慢时，它使用pull模型，当订阅者更快时使用push模型。

简单来说，在响应式流下订阅者可以与发布者沟通，如果使用JMS就应该知道，订阅者只能被动接收发布者所产生的消息数据。这就好比没有水龙头的水管一样，我只能被动接收水管里流过来的水，无法关闭也无法减少。而响应式流就相当于给水管加了个水龙头，在消费者这边可以控制水流的增加、减少及关闭。

响应式流模型图：

![image-20200224213958611](F:\响应式编程.assets\image-20200224213958611.png)

发布者（Publisher）是潜在的无限数量的有序元素的生产者。发布者可能有多个来自订阅者的待处理请求。

- 根据收到的要求向当前订阅者发布（或发送）元素。

订阅者（Subscriber）从发布者那里订阅并接收元素。订阅者可以请求更多的元素。

- 发布者向订阅者发送订阅令牌（Subscription）。
- 使用订阅令牌，订阅者从发布者那里请求多个元素。
- 当元素准备就绪时，发布者向订阅者发送多个或更少的元素。

## 3.2 Reactive Stream主要接口

JDK9 通过java.util.concurrent.Flow 和java.util.concurrent.SubmissionPublisher 类来实现响应式流。在JDK9里Reactive Stream的主要接口声明在Flow类里，Flow 类中定义了四个嵌套的静态接口，用于建立流量控制的组件，发布者在其中生成一个或多个供订阅者使用的数据项：

- Publisher：数据项发布者、生产者
- Subscriber：数据项订阅者、消费者
- Subscription：发布者与订阅者之间的关系纽带，订阅令牌
- Processor：数据处理器

![image-20200224214947991](F:\响应式编程.assets\image-20200224214947991.png)

`Publisher`是能够发出元素的发布者，`Subscriber`是接收元素并做出响应的订阅者。当执行`Publisher`里的`subscribe`方法时，发布者会回调订阅者的`onSubscribe`方法，这个方法中，通常订阅者会借助传入的`Subscription`向发布者请求n个数据。**然后发布者通过不断调用订阅者的`onNext`方法向订阅者发出最多n个数据**。如果数据全部发完，则会调用`onComplete`告知订阅者流已经发完；如果有错误发生，则通过`onError`发出错误数据，同样也会终止流。

其中，`Subscription`相当于是连接`Publisher`和`Subscriber`的“纽带”。因为当发布者调用`subscribe`方法注册订阅者时，会通过订阅者的回调方法`onSubscribe`传入`Subscription`对象，之后订阅者就可以使用这个`Subscription`对象的`request`方法向发布者“要”数据了。背压机制正是基于此来实现的。

![image-20200224215321624](F:\响应式编程.assets\image-20200224215321624.png)

`Processor`则是集`Publisher`和`Subscriber`于一身，相当于是发布者与订阅者之间的一个”中间人“，可以通过`Processor`进行一些中间操作：

```java
    /**
     * A component that acts as both a Subscriber and Publisher.
     *
     * @param <T> the subscribed item type
     * @param <R> the published item type
     */
    public static interface Processor<T,R> extends Subscriber<T>, Publisher<R> {
    }
```

## 3.3 响应流使用示例

示例1：以下代码简单演示了SubmissionPublisher 和这套发布-订阅框架的基本使用方式

```java
package com.example.demo;

import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;

public class FlowDemo {

    public static void main(String[] args) throws InterruptedException {
        //1.定义发布者，发布的数据类型是整型
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();
        //2.定义订阅者
        Flow.Subscriber subscriber = new Flow.Subscriber() {

            private Flow.Subscription subscription;

            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                // 保存订阅关系, 需要用它来给发布者响应
                this.subscription = subscription;
                //请求一个数据
                this.subscription.request(1);
            }

            @Override
            public void onNext(Object item) {
                //接收到一个数据，然后处理
                System.out.println("接受到的数据:" + item);
                //处理完成后再次请求数据
                this.subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
                //产生异常，告诉发布者不需要数据了
                this.subscription.cancel();
            }

            @Override
            public void onComplete() {
                System.out.println("数据接收完成！");
            }
        };
        try {
            //3.建立订阅关系
            publisher.subscribe(subscriber);
            //4.生产数据，并发布
            for (int i = 0; i < 3; i++) {
                System.out.println("生产数据：" + i);
                publisher.submit(i);
            }
        }catch (Exception e){

        }finally {
            //5.发送完毕，关闭发布者
            publisher.close();
        }
        Thread.sleep(3000);
    }
}
```

运行结果：

![image-20200224224330444](F:\响应式编程.assets\image-20200224224330444.png)

上文中提到过可以调节发布者的数据产出速度，那么这个速度是如何调节的呢？**关键就在于submit方法**，**该方法是一个阻塞方法**。需要先说明的是SubmissionPublisher里有一个数据缓冲区，用于缓冲发布者产生的数据，而这个缓冲区是利用一个Object数组实现的，缓冲区最大长度为256，再创建SubmissionPublisher对象时指定。

![image-20200224225130169](F:\响应式编程.assets\image-20200224225130169.png)

![image-20200224225151642](F:\响应式编程.assets\image-20200224225151642.png)

当这个缓冲区的数据满了之后，submit方法就会进入阻塞状态，发布者数据的产生速度就会变慢，以此实现调节发布者的数据产出速度。修改上面代码如下：

```java
package com.example.demo;

import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class FlowDemo {

    public static void main(String[] args) throws InterruptedException {
        //1.定义发布者，发布的数据类型是整型
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();
        //2.定义订阅者
        Flow.Subscriber subscriber = new Flow.Subscriber() {

            private Flow.Subscription subscription;

            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                // 保存订阅关系, 需要用它来给发布者响应
                this.subscription = subscription;
                //请求一个数据
                this.subscription.request(1);
            }

            @Override
            public void onNext(Object item) {
                //接收到一个数据，然后处理
                System.out.println("接受到的数据:" + item);
                try {
                    TimeUnit.SECONDS.sleep(3);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //处理完成后再次请求数据
                this.subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
                //产生异常，告诉发布者不需要数据了
                this.subscription.cancel();
            }

            @Override
            public void onComplete() {
                System.out.println("数据接收完成！");
            }
        };
        try {
            //3.建立订阅关系
            publisher.subscribe(subscriber);
            //4.生产数据，并发布
            for (int i = 0; i < 1000; i++) {
                System.out.println("生产数据：" + i);
                publisher.submit(i);
            }
        }catch (Exception e){

        }finally {
            //5.发送完毕，关闭发布者
            publisher.close();
        }
        Thread.sleep(3000);
    }
}
```

运行结果：

![image-20200224231027272](F:\响应式编程.assets\image-20200224231027272.png)

示例2：以下代码演示了结合Processor的使用方式

```java
package com.example.demo;

import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;

public class FlowDemo2 {

    static class MyProcessor extends SubmissionPublisher<String> implements Flow.Processor<Integer,String> {

        private Flow.Subscription subscription;

        @Override
        public void onSubscribe(Flow.Subscription subscription) {
            //保持订阅关系
            this.subscription = subscription;
            //请求一个数据
            this.subscription.request(1);
        }

        @Override
        public void onNext(Integer item) {
            //接受到数据，进行处理
            System.out.println("处理器接收数据：" + item);
            //处理完的数据再发送出去
            this.submit(item + "：I7处理器");
            //最后再请求下一个数据
            this.subscription.request(1);
        }

        @Override
        public void onError(Throwable throwable) {
            throwable.printStackTrace();
            //产生异常，告诉发布者不需要数据了
            this.subscription.cancel();
        }

        @Override
        public void onComplete() {
            System.out.println("处理器处理完毕");
            this.close();
        }
    }


    public static void main(String[] args) throws InterruptedException {
        //1.定义发布者，发布的数据类型是整型
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();
        //2.定义处理器，处理Integer类型数据
        MyProcessor processor = new MyProcessor();
        //3.发布者与处理器建立关系
        publisher.subscribe(processor);
        try (publisher) {
            //4.定义最终订阅者，消费String类型数据
            Flow.Subscriber<String> subscriber = new Flow.Subscriber() {

                private Flow.Subscription subscription;

                @Override
                public void onSubscribe(Flow.Subscription subscription) {
                    // 保存订阅关系, 需要用它来给发布者响应
                    this.subscription = subscription;
                    //请求一个数据
                    this.subscription.request(1);
                }

                @Override
                public void onNext(Object item) {
                    //接收到一个数据，然后处理
                    System.out.println("接受到的数据:" + item);
                    //处理完成后再次请求数据
                    this.subscription.request(1);
                }

                @Override
                public void onError(Throwable throwable) {
                    throwable.printStackTrace();
                    //产生异常，告诉发布者不需要数据了
                    this.subscription.cancel();
                }

                @Override
                public void onComplete() {
                    System.out.println("数据接收完成！");
                }
            };
            //5.建立处理器与最终订阅者的订阅关系
            processor.subscribe(subscriber);
            //6.生产数据，并发布,由处理器接收
            for (int i = 0; i < 3; i++) {
                System.out.println("生产数据：" + i);
                publisher.submit(i);
            }
        } catch (Exception ignored) {
        }
        //7.发送完毕，关闭发布者
        Thread.sleep(3000);
    }
}
```

运行结果：

![image-20200224230824969](F:\响应式编程.assets\image-20200224230824969.png)

## 3.4 运行机制

1、Subscription内部有一个Object数组，用来存储发布者发布的数据，在Subscriber中的onSubscribe方法中，在第一次请求数据前就已经将发布者发布的数据全部缓存下来，然后消费者直接从这个数组中获取数据。

2、当发布者发布的数据大于Object数组的最大长度时，此时发布者进入阻塞，等消费者从Object中读取数据后再生成新的数据。

3、通过控制消费者消费数据的速度进而控制生产者的生产速度。（背压）

# 四、WebFlux

## 4.1 基本概念

我们知道传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的，在Servlet3.1之后才有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上，因此它的运行环境的可选择行要比传统web框架多的多。

　　根据官方的说法，webflux主要在如下两方面体现出独有的优势：

　　1）非阻塞式

　　　　其实在servlet3.1提供了非阻塞的API，WebFlux提供了一种比其更完美的解决方案。使用非阻塞的方式可以利用较小的线程或硬件资源来处理并发进而提高其可伸缩性

　　2) 函数式编程端点

　　　　老生常谈的编程方式了，Spring5必须让你使用java8，那么函数式编程就是java8重要的特点之一，而WebFlux支持函数式编程来定义路由端点处理请求。

![image-20200225203548840](F:\响应式编程.assets\image-20200225203548840.png)

## 4.2 SpringMVC与Spring WebFlux

![image-20200225190832209](F:\响应式编程.assets\image-20200225190832209.png)

它们都可以用注解式编程模型，都可以运行在tomcat，jetty，undertow等servlet容器当中。但是SpringMVC采用命令式编程方式，代码一句一句的执行，这样更有利于理解与调试，而WebFlux则是基于异步响应式编程，对于初次接触的码农们来说会不习惯。对于这两种框架官方给出的建议是：

　　1）如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。

　　2）如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小

　　3）在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大

## 4.3 异步Servlet

问题1：为什么要使用异步Servlet？同步Servlet阻塞了什么？

阻塞了tomcat里面的servlet线程。当一个请求到底tomcat，tomcat会创建一个线程去处理这个请求，在这个线程中会调用对应的servlet来处理。

问题2：异步Servlet是怎么样工作的？

```java
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws javax.servlet.ServletException, IOException {
        //1.开启异步，获取异步上下文
        AsyncContext context = request.startAsync();
        //2.使用独立的线程执行业务代码
        CompletableFuture.runAsync(() -> {
            doSomeThing(context,context.getRequest(),context.getResponse());
        });
    }

    private void doSomeThing(AsyncContext context, ServletRequest request, ServletResponse response) {
        try {
            Thread.sleep(5000);
            response.getWriter().append("done");
        } catch (Exception e) {
            e.printStackTrace();
        }
        //3.业务代码执行完成后，通知上下文线程执行完毕
        context.complete();
    }
```

## 4.4 WebFlux入门

![image-20200225204829936](F:\响应式编程.assets\image-20200225204829936.png)

给出controller中的代码

```java
package com.example.webfluxdemo.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.stream.IntStream;

@RestController
@Slf4j
@RequestMapping("/")
public class TestController {

    @GetMapping("test1")
    public String test1(){
        log.info("test1 start");
        String res = createString();
        log.info("test1 end");
        return res;
    }

    @GetMapping("test2")
    public Mono<String> test2(){
        log.info("test2 start");
        Mono<String> res = Mono.fromSupplier(this::createString);
        log.info("test2 end");
        return res;
    }

    @GetMapping(value = "test3",produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> test3(){
        log.info("test3 start");
        Flux<String> res = Flux.fromStream(IntStream.range(1,10).mapToObj(i -> "Flux data:" + i));
        log.info("test3 end");
        return res;
    }

    private String createString() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "str";
    }
}
```

执行结果对比：

![image-20200225222709196](F:\响应式编程.assets\image-20200225222709196.png)

区别一目了然

Mono和Flux的原理，测试如下：

```java
package com.example.webfluxdemo;

import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public class ReactorDemo {

    public static void main(String[] args) {
        //Reactor = jdk8 Stream + jdk9 Reactive Stream
        //Mono 0-1个元素
        //Flux 0-n个元素
        String[] str = new String[]{"1","2","3"};
        Subscriber subscriber = new Subscriber() {

            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                // 保存订阅关系, 需要用它来给发布者响应
                this.subscription = subscription;
                //请求一个数据
                this.subscription.request(1);
            }

            @Override
            public void onNext(Object item) {
                //接收到一个数据，然后处理
                System.out.println("接受到的数据:" + item);
                //处理完成后再次请求数据
                this.subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
                //产生异常，告诉发布者不需要数据了
                this.subscription.cancel();
            }

            @Override
            public void onComplete() {
                System.out.println("数据接收完成！");
            }
        };

        //jdk8中的Stream
        Mono.fromSupplier(() -> "string").map(String::length)
                //最终操作
                //jdk9中的Reactive Stream
                .subscribe(subscriber);
        
        //jdk8中的Stream
        Flux.fromArray(str).map(Integer::parseInt)
                //最终操作
                //jdk9中的Reactive Stream
                .subscribe(subscriber);
    }
}
```

执行结果：

![image-20200225215414869](F:\响应式编程.assets\image-20200225215414869.png)

## 4.5 SSE（Server-Sent Event）

所谓的SSE(Sever-Sent Event),就是浏览器向服务器发送了一个HTTP请求，保持长连接，服务器不断单向地向浏览器推送“信息”，这么做是为了节省网络资源，不用一直发请求，建立新连接。

- 优点：SSE和WebSocket相比，最大的优势是便利，服务端不需要第三方组件，开发难度低，SSE和轮询相比它不用处理很多请求，不用每次建立新连接，延迟低。
- 缺点：如果客户端有很多需要保持很多长连接，这回占用大量内存和连接数。

### 4.5.1 客户端实现

```js
if(typeof(EventSource)!=="undefined") {   //判断是否支持EventSource
      var source = new EventSource('push'); //为http://localhost:8080/sse/push
      source.addEventListener('message', function (e) {
      }
      source.addEventListener('open', function (e) {
      }
      source.addEventListener('error', function (e) {
      }
}
```

支持默认3种事件，连接一旦建立就会触发open事件，客户端收到服务器发来的数据，就会触发message事件，如果发生通讯错误（如断开连接）就会触发error事件。

默认情况，服务器发来的数据，总是触发message事件，开发者也可以自定义SSE事件，这种情况下，发送回来的数据不会触发message事件。

```js
source.addEventListener('foo', function (event) {
  var data = event.data;
  // handle message
}, false);
```

上面的例子中使用foo事件监听。

```html
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
    <script>
      var sse = new EventSource("Servlet")
      sse.onmessage = function (evt) {
          document.write(evt.data + "<br/>")
      }
    </script>
  </body>
</html>
```

### 4.5.2 服务端实现

服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息。

```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

每一次发送的信息，由若干个message组成，每个message之间用\n\n分隔。每个message内部由若干行组成，每一行都是如下格式。

```
[field]: value\n
```

上面的field可以取四个值。

```
data   //数据项
event //事件项 默认message
id //数据标识符用id字段表示，相当于每一条数据的编号
retry //重连时间
```

此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。

```
: This is a comment
```

一般发送格式：

```
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}
retry:1000
```

```java
    protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
        response.setContentType("text/event-stream");
        response.setCharacterEncoding("utf-8");

        for (int i = 0; i < 10; i++) {
            response.getWriter().write("data:" + i + "\n\n");
            response.getWriter().flush();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
```

### 4.5.3 问题

1、长连接是如果实现的？

![image-20200226185601362](F:\响应式编程.assets\image-20200226185601362.png)

我们可以看到每个请求只返回了一次数据，服务器每次发完数据就断开了连接，但SSE默认会自动重连，所以客户端不断地重连（重新发送请求），但这样就类似ajax长轮询，并不减少网络资源占用。

*SSE 浏览器默认如果3秒内没有发送任何信息，则开始重连。服务器端可以用retry参数信息，指定通信的最大间隔时间*

改进方案：

```java
protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
        response.setContentType("text/event-stream");
        response.setCharacterEncoding("utf-8");
        while (true) {
            response.getWriter().write("data: test123\n\n");
            response.getWriter().flush();
        }
    }
```

![image-20200226185943900](F:\响应式编程.assets\image-20200226185943900.png)

这样就实现了客户端只发送一次请求，服务器不断地单向推送消息，保持长连接。

2、如何跳出循环

我们写了`while(true)`让它保持连接，不停地推送数据，但是浏览器关闭了却没有抛出异常，这里很奇怪为什么连接关闭了还能执行flush方法？这样的话浏览器关闭了，服务器却仍在执行while循环，这种情况显然是不允许的。

问题解决：
 查阅了PrintWriter源码后发现，在flush方法中已经对异常做了处理，所以调用时不会抛出异常，我们要检测异常可以调用它的checkError()函数。

```java
    /**
     * Flushes the stream.
     * @see #checkError()
     */
    public void flush() {
        try {
            synchronized (lock) {
                ensureOpen();
                out.flush();
            }
        }
        catch (IOException x) {
            trouble = true;
        }
    }
```

我们关闭浏览器后，服务器下一次要推送时就会抛出异常，这个异常已经在PrintWriter的flush()中被捕捉了，我们只需它的调用checkError()，有错误的话break即可停止执行。

```java
protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
        response.setContentType("text/event-stream");
        response.setCharacterEncoding("utf-8");
        int count = 0;
        while (true) {
            System.out.println("while执行了" + count++ + "次");
            PrintWriter writer = response.getWriter();
            writer.write("data: test123\n\n");
            writer.flush();
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (writer.checkError()){
                System.out.println("while执行中断");
                break;
            }
        }
    }
```

![image-20200226190614889](F:\响应式编程.assets\image-20200226190614889.png)

可以看到浏览器关闭了以后，服务器也跳出了这个循环

如果客户端想在不关闭页面的情况下主动关闭连接，只需要设置一个按钮，点击以后调用EventSource.colse()即可关闭连接，服务端推送数据时因为连接已经关闭，就会抛出异常，跳出循环。

```html
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
    <button onclick="start()">开始</button>
    <button onclick="stop()">停止</button>
    <div id="div"></div>
    <script>
        var sse;
      function start() {
          sse = new EventSource("Servlet")
          sse.onmessage = function (evt) {
              document.getElementById("div").textContent = evt.data + "<br/>"
          }
      }
      function stop() {
          sse.close();
      }
    </script>
  </body>
</html>
```

## 4.6 基本CRUD（基于SpringMVC）

### 4.6.1 依赖

```xml
	<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
        </dependency>
	</dependencies>
```

### 4.6.2 配置文件

```yaml
server:
  port: 8888
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/webflux
```

### 4.6.3 POJO

```java
package com.example.webfluxdemo.pojo;

import lombok.Data;
import org.hibernate.validator.constraints.Range;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import javax.validation.constraints.NotBlank;

@Document(collection = "user")
@Data
public class User {

    @Id
    private String id;

    @NotBlank
    private String name;

    @Range(min = 1,max = 99)
    private Integer age;
}
```

### 4.6.4 Controller

主要完成的功能有：

1、以数组的形式查询所有用户信息

2、以SSE的形式查询所有用户信息

3、新增用户信息

**4、根据id删除用户信息**

**5、根据用户id修改用户信息**

6、根据id查询用户信息

7、根据用户年龄段进行查询（使用JPA）

8、根据用户年龄段进行查询（执行mongodb的查询语句）

9、根据用户年龄段进行查询（返回SSE）

```java
package com.example.webfluxdemo.controller;

import com.example.webfluxdemo.pojo.User;
import com.example.webfluxdemo.repository.UserRepository;
import com.example.webfluxdemo.util.CheckUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import javax.validation.Valid;

@RestController
@RequestMapping("/user")
public class UserController {

    private final UserRepository userRepository;

    @Autowired
    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * 以数组的形式获取全部用户
     * @return
     */
    @GetMapping("/")
    public Flux<User> getAll(){
        return this.userRepository.findAll();
    }

    /**以SSE的方式获取全部用户
     *
     * @return
     */
    @GetMapping(value = "/stream/",produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<User> streamGetAll(){
        return this.userRepository.findAll();
    }


    /**
     * 新增用户信息
     * @param user
     * @return
     */
    @PostMapping("/")
    public Mono<User> addUser(@Valid @RequestBody User user){
        CheckUtil.checkName(user.getName());
        return this.userRepository.save(user);
    }

    /**
     * 根据id删除用户信息
     * @return
     */
    @DeleteMapping("/{id}")
    public Mono<ResponseEntity<Void>> deleteUserById(@PathVariable("id") String id){
        return this.userRepository.findById(id)
                //当对数据进行操作的时，并返回一个Mono,这个时候使用flatMap
                //如果只对数据进行转换，使用map
                .flatMap(user -> this.userRepository.delete(user).then(Mono.just(new ResponseEntity<Void>(HttpStatus.OK))))
                .defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }


    /**
     * 根据用户id来修改数据
     * @param id
     * @param user
     * @return
     */
    @PutMapping("/{id}")
    public Mono<ResponseEntity<User>> updateUser(@PathVariable("id") String id,@Valid @RequestBody User user){
        CheckUtil.checkName(user.getName());
        return this.userRepository.findById(id)
                .flatMap(u -> {
                    u.setAge(user.getAge());
                    u.setName(user.getName());
                    return this.userRepository.save(u);
                })
                .map(u -> new ResponseEntity<>(u, HttpStatus.OK))
                .defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    /**
     * 根据id查询用户信息
     * @param id
     * @return
     */
    @GetMapping("/{id}")
    public Mono<ResponseEntity<User>> findUserById(@PathVariable("id") String id){
        return this.userRepository.findById(id)
                   .map(u -> new ResponseEntity<>(u,HttpStatus.OK))
                   .defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    /**
     * 根据年龄段查询
     * @param start
     * @param end
     * @return
     */
    @GetMapping("/age/{start}/{end}")
    public Flux<User> findUserByAge(@PathVariable("start") Integer start,@PathVariable("end") Integer end){
        return this.userRepository.findByAgeBetween(start,end);
    }


    /**
     * 根据年龄段查询
     * @param start
     * @param end
     * @return
     */
    @GetMapping(value = "stream/age/{start}/{end}",produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<User> streamFindUserByAge(@PathVariable("start") Integer start,@PathVariable("end") Integer end){
        return this.userRepository.findByAgeBetween(start,end);
    }


    /**
     * 根据年龄段查询用户
     * @param start
     * @param end
     * @return
     */
    @GetMapping(value = "/age/mongodb/{start}/{end}")
    public Flux<User> findUserByAge2(@PathVariable("start") Integer start,@PathVariable("end") Integer end){
        return this.userRepository.findByAge(start,end);
    }
}
```

### 4.6.4 Repository

注意mongodb的查询语句中参数的替换。

```java
package com.example.webfluxdemo.repository;

import com.example.webfluxdemo.pojo.User;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;

@Repository
public interface UserRepository extends ReactiveMongoRepository<User,String> {

    Flux<User> findByAgeBetween(int start,int end);

    @Query("{'age':{'$gte':?#{[0]},'$lte':?#{[1]}}}")
    Flux<User> findByAge(int start,int end);
}
```

### 4.6.5 异常处理

对输入参数进行校验，在这里提供了两种方法，第一种是使用Hibernate注解的方式，在实体类中对应字段上添加注解，然后在Controller中需要进行参数校验的地方添加@Valid注解；第二种是通过自定义异常来完成，主要流程如下：

1、定义检查异常类CheckException，继承运行时异常RuntimeException，并且定义两个字段filedName，用来显示要检查的字段，filedValue用来显示具体的错误内容。

2、创建自定义异常抛出类ExceptionCast，用来抛出运行时异常。

3、创建CheckUtil工具类，在类中给出对用户name字段的校验方法，并且在需要的地方进行调用。

4、定义Controller切面CheckAdvice，在这里捕获具体的异常然后将信息封装返回。

```java
package com.example.webfluxdemo.exception;

import lombok.Data;

@Data
public class CheckException extends RuntimeException {

    private String filedName;
    private String filedValue;

    public CheckException(String filedName, String filedValue) {
        this.filedName = filedName;
        this.filedValue = filedValue;
    }
}
```

```java
package com.example.webfluxdemo.exception;

public class ExceptionCast {

    public static void cast(String name,String value){
        throw new CheckException(name,value);
    }
}
```

```java
package com.example.webfluxdemo.advice;

import com.example.webfluxdemo.exception.CheckException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.support.WebExchangeBindException;

/**
 * 异常处理
 */
@ControllerAdvice
public class CheckAdvice {

    @ExceptionHandler(WebExchangeBindException.class)
    public ResponseEntity<String> handleBindException(WebExchangeBindException e){
        return new ResponseEntity<>(str(e),HttpStatus.NOT_FOUND);
    }


    @ExceptionHandler(CheckException.class)
    public ResponseEntity<String> handleCheckException(CheckException e){
        return new ResponseEntity<>(str(e),HttpStatus.NOT_FOUND);
    }

    private String str(CheckException ex) {
        return "错误的" + ex.getFiledName() + ":" + ex.getFiledValue();
    }

    private String str(WebExchangeBindException ex) {
        return ex.getFieldErrors().stream()
                .map(e -> e.getField() + ":" + e.getDefaultMessage())
                .reduce("",(s1,s2) -> s1 + s2);
    }
}
```

```java
package com.example.webfluxdemo.util;

import com.example.webfluxdemo.exception.ExceptionCast;

import java.util.stream.Stream;

public class CheckUtil {

    private static final String[] INVALID_NAMES = new String[]{"admin","管理员"};

    public static void checkName(String value) {
        Stream.of(INVALID_NAMES)
                .filter(name -> name.equalsIgnoreCase(value))
                .findAny()
                .ifPresent(name -> ExceptionCast.cast("name",name));
    }
}
```

### 4.6.6 运行结果

1、新增用户信息

![image-20200227211322644](http://mycsdnblog.work/202020162012-V.png)

name为空的情况：

![image-20200227214122661](http://mycsdnblog.work/202020162013-I.png)

age超过范围：

![image-20200227214152919](http://mycsdnblog.work/202020162013-X.png)

name为admin：

![image-20200227214347375](http://mycsdnblog.work/202020162014-3.png)

2、以数组的形式查询所有用户信息

![image-20200227211535113](http://mycsdnblog.work/202020162014-I.png)

3、以SSE的形式查询所有用户信息

![image-20200227211847692](http://mycsdnblog.work/202020162014-n.png)

**4、根据id删除用户信息**

![image-20200227211949023](http://mycsdnblog.work/202020162014-6.png)

再次查询

![image-20200227212013702](http://mycsdnblog.work/202020162014-L.png)

输入错误的id：

![image-20200227212059222](http://mycsdnblog.work/202020162015-y.png)

**5、根据用户id修改用户信息**

![image-20200227212313386](http://mycsdnblog.work/202020162015-e.png)

6、根据id查询用户信息

![image-20200227212438800](http://mycsdnblog.work/202020162015-o.png)

7、根据用户年龄段进行查询（使用JPA）

![image-20200227212510265](http://mycsdnblog.work/202020162015-9.png)

8、根据用户年龄段进行查询（执行mongodb的查询语句）

![image-20200227213918145](http://mycsdnblog.work/202020162016-9.png)

9、根据用户年龄段进行查询（返回SSE）

![image-20200227212540884](http://mycsdnblog.work/202020162016-v.png)

## 4.7 RouterFunction模式

ServerRequest<----------------->HttpServletRequest

ServerResponse<----------------->HttpServletResponse

开发过程

1、HandlerFunction(输入ServerRequest返回ServerResponse)

2、RouteFunction(请求URL和HandlerFunction的关联)

3、HttpHandler

4、Server处理

### 4.7.1 HandlerFunction

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package org.springframework.web.reactive.function.server;

import reactor.core.publisher.Mono;

@FunctionalInterface
public interface HandlerFunction<T extends ServerResponse> {
    Mono<T> handle(ServerRequest var1);
}
```

主要编写的是输入为`ServerRequest`返回为`Mono<ServerResponse>`的方法，然后在`RouterFunction`中调用。

具体的逻辑处理

```java
package com.example.webfluxdemo.handlers;

import com.example.webfluxdemo.pojo.User;
import com.example.webfluxdemo.repository.UserRepository;
import com.example.webfluxdemo.util.CheckUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

@Component
public class UserHandler {

    private final UserRepository userRepository;

    @Autowired
    public UserHandler(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * 获取所有用户
     * @param request
     * @return
     */
    public Mono<ServerResponse> getAllUser(ServerRequest request){
        return ServerResponse
                .ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(this.userRepository.findAll(),User.class);
    }

    /**
     * 添加用户
     * @param request
     * @return
     */
    public Mono<ServerResponse> addUser(ServerRequest request){
        Mono<User> userMono = request.bodyToMono(User.class);
        //异常处理
        return userMono.flatMap(user -> {
            CheckUtil.checkName(user.getName());
            return ServerResponse
                    .ok()
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(this.userRepository.save(user),User.class);
        });
//        return ServerResponse
//                .ok()
//                .contentType(MediaType.APPLICATION_JSON)
//                .body(this.userRepository.saveAll(userMono),User.class);
    }

    /**
     * 根据id删除用户
     * @param request
     * @return
     */
    public Mono<ServerResponse> deleteUserById(ServerRequest request){
        String id = request.pathVariable("id");
        return this.userRepository.findById(id)
                .flatMap(this.userRepository::delete)
                .then(ServerResponse.ok().build())
                .switchIfEmpty(ServerResponse.notFound().build());
    }
    
        /**
     * 根据id查询用户
     * @param request
     * @return
     */
    public Mono<ServerResponse> getUserById(ServerRequest request){
        String id = request.pathVariable("id");
        return this.userRepository.findById(id)
                .flatMap(user -> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(user))
                .switchIfEmpty(ServerResponse.notFound().build());
    }
}
```

### 4.7.2 RouteFunction

功能类似SpirngMVC中的Dispatchservlet，即URL匹配指定的处理方法。

注意参数问题

```java
package com.example.webfluxdemo.routes;

import com.example.webfluxdemo.handlers.UserHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.*;


import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.*;


/**
 * 功能类似SpirngMVC中的Dispatchservlet
 */
@Configuration
public class AllRoute {

    @Bean
    RouterFunction<ServerResponse> userRoute(UserHandler userHandler){
        return nest(
                path("/routerfunction/user"),
                //这里面的参数调用时怎么回事?
                route(GET("/"),userHandler::getAllUser)
                .andRoute(POST("/").and(accept(MediaType.APPLICATION_JSON)),userHandler::addUser)
                .andRoute(DELETE("/{id}"),userHandler::deleteUserById)
                .andRoute(GET("/{id}"),userHandler::getUserById)
        );
    }
}
```

不同的写法2：

```java
package com.example.webfluxdemo.routes;

import com.example.webfluxdemo.handlers.UserHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.*;


import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.*;


/**
 * 功能类似SpirngMVC中的Dispatchservlet
 */
@Configuration
public class AllRoute {

    @Bean
    RouterFunction<ServerResponse> userRoute(UserHandler userHandler){
                return route()
                .path("/routerfunction/user",builder ->
                    builder
                            .GET("/",userHandler::getAllUser)
                            .POST("/",accept(MediaType.APPLICATION_JSON),userHandler::addUser)
                            .DELETE("/{id}",userHandler::deleteUserById)
                            .GET("/{id}",userHandler::getUserById)

                )
                .build();
    }
}
```

不同的写法3：

```java
package com.example.webfluxdemo.routes;

import com.example.webfluxdemo.handlers.UserHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.*;


import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.*;


/**
 * 功能类似SpirngMVC中的Dispatchservlet
 */
@Configuration
public class AllRoute {

    @Bean
    RouterFunction<ServerResponse> userRoute(UserHandler userHandler){
		return route().path("/routerfunction",builder ->
                    builder.nest(path("/user"),builder2 ->
                        builder2.POST("/",userHandler::addUser)
                                .GET("/",userHandler::getAllUser)
                                .DELETE("/{id}",userHandler::deleteUserById)
                                .GET("/{id}",userHandler::getUserById)
                    ).nest(path("/test"),builder3 -> builder3.GET("/",userHandler::test))

        ).build();
    }
}
```

在这里说明一下，userHandler中各个方法所需的ServerRequest参数是如何传入的。

```java
RouterFunctions.Builder GET(String var1, HandlerFunction<ServerResponse> var2);
```

```java
    public static <T extends ServerResponse> RouterFunction<T> route(RequestPredicate predicate, HandlerFunction<T> handlerFunction) {
        return new RouterFunctions.DefaultRouterFunction(predicate, handlerFunction);
    }
```

上面两个方法的第二个参数都是HandlerFunction，即输入一个ServerRequest，返回一个Mono<T>，所以GET方法也可以写成如下形式：

```java
GET("/",serverRequest -> userHandler.getAllUser(serverRequest))
```

因为传入的参数与实际使用的参数相同他，所以替换成方法引用为：

```java
GET("/", userHandler::getAllUser)
```

### 4.7.3 异常处理

注意：要使用注解@Order来指定异常的优先级，越小优先级越高

```java
package com.example.webfluxdemo.advice;

import com.example.webfluxdemo.exception.CheckException;
import org.springframework.core.annotation.Order;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebExceptionHandler;
import reactor.core.publisher.Mono;


@Component
@Order(-2) //提高自定义异常的优先级
public class ExceptionHandler implements WebExceptionHandler {
    @Override
    public Mono<Void> handle(ServerWebExchange serverWebExchange, Throwable throwable) {
        //1.设置响应头
        ServerHttpResponse response = serverWebExchange.getResponse();
        response.setStatusCode(HttpStatus.BAD_REQUEST);
        //2.设置返回类型
        response.getHeaders().setContentType(MediaType.TEXT_PLAIN);
        //3.处理异常信息
        String res = str(throwable);
        DataBuffer db = response.bufferFactory().wrap(res.getBytes());
        return response.writeWith(Mono.just(db));
    }

    private String str(Throwable ex) {
        //1.已知异常
        if (ex instanceof CheckException){
            CheckException exception = (CheckException) ex;
            return "错误的" + exception.getFiledName() + ":" + exception.getFiledValue();
        }else {
            //2.未知异常
            ex.printStackTrace();
            return ex.toString();
        }
    }
}
```

### 4.7.4 运行结果

1、查询所有用户信息

![image-20200228091713238](http://mycsdnblog.work/202020162035-C.png)

2、添加用户信息

![image-20200228091915553](http://mycsdnblog.work/202020162035-2.png)

错误校验——非法用户名

![image-20200228091951211](http://mycsdnblog.work/202020162035-u.png)

3、删除用户信息

![image-20200228092501292](http://mycsdnblog.work/202020162035-D.png)

再次删除

![image-20200228112327249](http://mycsdnblog.work/202020162036-s.png)

4、查询用户信息

![image-20200228122907558](http://mycsdnblog.work/202020162036-Z.png)

输入错误的id

![image-20200228122924349](http://mycsdnblog.work/202020162036-C.png)

## 4.8 WebClient开发

### 4.8.1 最终效果

```java
package com.example.webfluxclient.api;

import webclient.annotation.ApiServer;
import com.example.webfluxclient.pojo.User;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@ApiServer(url = "http://localhost:8888/routerfunction/user/")
public interface UserApi {

    @GetMapping("/")
    Flux<User> getAllUser();

    @GetMapping("/{id}")
    Mono<User> findUserById(@PathVariable("id") String id);

    @DeleteMapping("/{id}")
    Mono<Void> deleteUserById(@PathVariable("id") String id);

    @PostMapping("/")
    Mono<User> addUser(@RequestBody Mono<User> user);
}
```

在Controller中调用UserApi中的各个方法就可以完成远程服务的调用。各种请求方式使用的还是Spring提供的，注解@ApiServer是自己创建的。

```java
package webclient.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiServer {

    String url() default "";
}
```

### 4.8.2 设计思路

根据最终效果，可以初步给出总体设计思路：

**使用动态代理来代理这个UserApi接口，然后获取接口上的注解信息形抽取为服务器信息实体，然后再获取各个方法上的注解信息、参数信息构成具体的请求方法信息实体，然后在服务启动的时候将这个代理类注入到Spring容器当中，最后在调用此接口的时候在代理类中通过WebClient完成具体的方法调用。**

![image-20200229174712417](http://mycsdnblog.work/202020162042-d.png)

### 4.8.3 具体实现

> 第一步：使用FactoryBean将代理类注入到Spring容器当中

```java
    @Bean
    ProxyCreator createProxy(){
        return new JDKProxyCreator();
    }

    @Bean
    FactoryBean<UserApi> getUserApi(ProxyCreator proxyCreator){
        return new FactoryBean<UserApi>() {
            @Override
            public UserApi getObject() throws Exception {
                return (UserApi)proxyCreator.createProxy(this.getObjectType());
            }

            @Override
            public Class<?> getObjectType() {
                return UserApi.class;
            }
        };
    }
```

需要注意的地方：

1、动态代理的方式可能使用JDK动态代理或者CGLIB代理，所以针对以后可能存在的修改，这里面在创建具体代理对象时使用接口来创建。

```java
package webclient.proxy;

/**
 * 创建代理类的接口
 */
public interface ProxyCreator {
    Object createProxy(Class<?> type);
}
```

然后根据具体的实现方式来实现这个接口，这里使用JDK动态代理。

```java
package webclient.proxy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpMethod;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import webclient.annotation.ApiServer;
import webclient.handle.RestHandler;
import webclient.handle.WebClientRestHandler;
import webclient.pojo.MethodInfo;
import webclient.pojo.ServerInfo;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 使用jdk动态代理来实现代理类
 */
@Slf4j
public class JDKProxyCreator implements ProxyCreator {

    @Override
    public Object createProxy(Class<?> type) {

    }
}

```

在这里完成动态代理类的创建，以及主要的调用工作在这里完成。

2、具体方法调用的时候，可能使用不同的Restful API调用框架，所以创建方法调用也要使用接口的形式。

```java
package webclient.handle;

import webclient.pojo.MethodInfo;
import webclient.pojo.ServerInfo;

public interface RestHandler {

    /**
     * 初始化服务器信息
     * @param serverInfo
     */
    void init(ServerInfo serverInfo);

    /**
     * 调用rest请求，返回结果
     * @param methodInfo
     * @return
     */
    Object invokeRest(MethodInfo methodInfo);
}
```

接口中提供两个方法，一个是初始化init接口，主要完成服务器信息的设置，参数是ServerInfo；另一个是具体的请求调用方法，完成具体方法的调用，参数是MethodInfo。

这里面需要的ServerInfo和MethodInfo都是在JDKProxyCreator类中创建代理类的过程中获取到信息。

这样整体的代码框架就有了，接下来需要完成的工作就是JDKProxyCreator类中的createProxy方法的实现，以及RestHandler接口的实现。

> 第二步：实现接口的动态代理

```java
package webclient.proxy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpMethod;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import webclient.annotation.ApiServer;
import webclient.handle.RestHandler;
import webclient.handle.WebClientRestHandler;
import webclient.pojo.MethodInfo;
import webclient.pojo.ServerInfo;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 使用jdk动态代理来实现代理类
 */
@Slf4j
public class JDKProxyCreator implements ProxyCreator {

    @Override
    public Object createProxy(Class<?> type) {
        log.info("type:" + type);
        //1.根据接口获取服务器信息
        ServerInfo serverInfo = getServerInfo(type);
        log.info("serverInfo:" + serverInfo);
        /**
         * 给每一个代理类创建一个RestHandler，如果有多个实现类就不会冲突
         */
        RestHandler restHandler = new WebClientRestHandler();
        restHandler.init(serverInfo);
        //2.创建代理对象
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[]{type}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws 		           Throwable {
                        //3.得到具体方法的调用信息
                        MethodInfo methodInfo = getMethodInfo(method,args);
                        log.info("methodInfo:" + methodInfo);
                        return restHandler.invokeRest(methodInfo);
            		}
            /**
             * 获取方法调用相关信息
             * @param method
             * @param args
             * @return
             */
            private MethodInfo getMethodInfo(Method method, Object[] args) {
                MethodInfo methodInfo = new MethodInfo();
                //1.获取请求地址和请求方法
                getMethodAndUrl(method, methodInfo);
                //2.获取路径参数和body中携带的数据
                getParamsAndBody(method, args, methodInfo);
                //3.获取方法返回的数据类型已经对象类型
                getReturnDataAndClassType(method,methodInfo);
                return methodInfo;
            }
        });
    }

    private ServerInfo getServerInfo(Class<?> type) {
        Annotation[] annotations = type.getAnnotations();
        for (Annotation annotation : annotations){
            if (annotation instanceof ApiServer){
                return new ServerInfo(((ApiServer)annotation).url());
            }
        }
        return null;
    }
}
```

1、通过getServerInfo方法来获取服务器信息，通过扫描代理对象上的注解来完成信息提取。

2、创建RestHandler，并根据服务器信息进行初始化

3、代理对象的创建，通过Proxy.newProxyInstance()方法来完成，传入三个参数：

```java
ClassLoader loader   类加载器
Class<?>[] interfaces  代理接口
InvocationHandler h  
```

4、实现InvocationHandler接口，然后在invoke方法中使用getMethodInfo获取具体的方法调用信息，具体包括：请求地址和请求方法信息、路径参数和body中携带的数据、方法返回的数据类型(Flux or Mono)和具体的对象类型。具体方法的实现如下，核心都是使用Java反射技术，获取方法的各种信息。

```java
private void getReturnDataAndClassType(Method method, MethodInfo methodInfo) {
                /**
                 * 获取返回数据的格式Flux or Mono
                 */
                /**
                 * isAssignableFrom()方法是从类继承的角度去判断，instanceof关键字是从实例继承的角度去判断。
                 * isAssignableFrom()方法是判断是否为某个类的父类，instanceof关键字是判断是否某个类的子类。
                 */
                boolean isFlux = method.getReturnType().isAssignableFrom(Flux.class);
                methodInfo.setReturnDataType(isFlux);
                /**
                 * 获取返回对象的实际类型
                 */
                methodInfo.setReturnClassType(getActualType(method.getGenericReturnType()));
            }

            /**
             * 获取路径参数和body中携带的数据
             * @param method
             * @param args
             * @param methodInfo
             */
            private void getParamsAndBody(Method method, Object[] args, MethodInfo methodInfo) {
                ConcurrentHashMap<String,Object> params = new ConcurrentHashMap<>();
                Parameter[] parameters = method.getParameters();
                for (int i = 0; i < parameters.length; i++) {
                    Annotation[] parameterAnnotations = parameters[i].getAnnotations();
                    for (Annotation annotation : parameterAnnotations){
                        if (annotation instanceof PathVariable){
                            PathVariable pathVariable = (PathVariable) annotation;
                            String key = pathVariable.value();
                            Object value = args[i];
                            params.put(key,value);
                        }else if (annotation instanceof RequestBody){
                            methodInfo.setBody((Mono<?>) args[i]);
                            Parameter parameter = parameters[i];
                            //重点，获取参数的实际类型
                            methodInfo.setBodyElementType(getActualType(parameter.getParameterizedType()));
                        }
                    }
                }
                methodInfo.setParams(params);
            }

            /**
             * 获取请求地址和请求方法
             * @param method
             * @param methodInfo
             */
            private void getMethodAndUrl(Method method, MethodInfo methodInfo) {
                Annotation[] annotations = method.getAnnotations();
                for (Annotation annotation : annotations){
                    if (annotation instanceof GetMapping){
                        GetMapping getMapping = (GetMapping) annotation;
                        methodInfo.setMethod(HttpMethod.GET);
                        methodInfo.setUrl(getMapping.value()[0]);
                    }else if (annotation instanceof PostMapping){
                        PostMapping postMapping = (PostMapping) annotation;
                        methodInfo.setMethod(HttpMethod.POST);
                        methodInfo.setUrl(postMapping.value()[0]);

                    }else if (annotation instanceof DeleteMapping){
                        DeleteMapping deleteMapping = (DeleteMapping) annotation;
                        methodInfo.setMethod(HttpMethod.DELETE);
                        methodInfo.setUrl(deleteMapping.value()[0]);

                    }else if (annotation instanceof PutMapping){
                        PutMapping putMapping = (PutMapping) annotation;
                        methodInfo.setMethod(HttpMethod.PUT);
                        methodInfo.setUrl(putMapping.value()[0]);

                    }
                }
            }

            /**
             * 获取泛型的实际类型
             * @param genericReturnType
             * @return
             */
            private Class<?> getActualType(Type genericReturnType) {
                ParameterizedType parameterizedType = (ParameterizedType) genericReturnType;
                return (Class<?>)parameterizedType.getActualTypeArguments()[0];
            }
```

5、最后使用RestHandler中的invokeRest方法完成http调用，返回调用结果。

> 第三步：RestHandler的实现

```java
package webclient.handle;

import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import webclient.exception.MyException;
import webclient.pojo.MethodInfo;
import webclient.pojo.ServerInfo;

public class WebClientRestHandler implements RestHandler{
    /**
     * 使用webclient完成远程服务调用
     * @param serverInfo
     */

    private WebClient client;

    @Override
    public void init(ServerInfo serverInfo) {
        this.client = WebClient.create(serverInfo.getUrl());

    }

    /**
     * 处理Restful请求
     * @param methodInfo
     * @return
     */
    @Override
    public Object invokeRest(MethodInfo methodInfo) {
        Object result;
        WebClient.RequestBodySpec request = this.client
                //请求方法
                .method(methodInfo.getMethod())
                //请求地址
                .uri(methodInfo.getUrl(), methodInfo.getParams())
                //设置接收数据的类型
                .accept(MediaType.APPLICATION_JSON);
        if (methodInfo.getBody() != null){
            request.body(methodInfo.getBody(),methodInfo.getBodyElementType());
        }
        //发出请求
        WebClient.ResponseSpec retrieve = request.retrieve();
        //异常处理
        retrieve.onStatus(httpStatus -> httpStatus.value() == 404,
                clientResponse -> Mono.just(new MyException("找不到用户",404)));

        if (methodInfo.getReturnDataType()){
            result = retrieve.bodyToFlux(methodInfo.getReturnClassType());
        }else {
            result = retrieve.bodyToMono(methodInfo.getReturnClassType());
        }
        return result;
    }
}
```

在这里主要通过WebClient来完成具体的http请求的发送。指定服务器地址、设置请求方法、请求地址、设置接收数据的类型，然后设置请求体中携带的json数据，最后发送请求。根据返回的状态码进行异常处理，返回自定义异常信息，最终的调用结果根据具体的返回类型来进行封装。

自定义异常：

```java
package webclient.exception;

public class MyException extends RuntimeException {

    String message;
    Integer code;

    public MyException(String message, Integer code) {
        this.message = message;
        this.code = code;
    }

    @Override
    public String toString() {
        return "MyException{" +
                "message='" + message + '\'' +
                ", code=" + code +
                '}';
    }

    @Override
    public String getMessage() {
        return this.toString();
    }
}
```

补充：MethodInfo和ServerInfo

```java
package webclient.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.http.HttpMethod;
import reactor.core.publisher.Mono;

import java.util.concurrent.ConcurrentHashMap;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MethodInfo {

    /**
     * 请求方式
     */
    private HttpMethod method;

    /**
     * 请求地址
     */
    private String url;

    /**
     * 路径参数
     */
    private ConcurrentHashMap<String,Object> params;

    /**
     * 请求body
     */
    private Mono<?> body;

    /**
     * 请求字段的类型
     */
    private Class<?> bodyElementType;

    /**
     * 返回类型，Mono还是Flux
     */
    private Boolean returnDataType;

    /**
     * 返回对象的类型
     */
    private Class<?> returnClassType;
}
```

```java
package webclient.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServerInfo {

    private String url;
}
```