# 一、多线程之间通讯

多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。

# 二、生产者-消费者



# 三、wait、notify方法

1.因为涉及到对象锁,他们必须都放在synchronized中来使用. Wait、Notify一定要在synchronized里面进行使用。

2.Wait必须暂停当前正在执行的线程,并释放资源锁,让其他线程可以有机会运行

3.notify/notifyall: 唤醒因锁池中的线程,使之运行

**注意:一定要在线程同步中使用,并且是同一个锁的资源**

需要线程通讯标识

# 四、wait与sleep区别

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。

在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

# 五、Lock锁

在 jdk1.5 之后，并发包中新增了 Lock 接口(以及相关实现类)用来实现锁功能，Lock 接口提供了与 synchronized 关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。

```java
Lock lock  = new ReentrantLock();
lock.lock();
try{
//可能会出现线程安全的操作
}finally{
//一定在finally中释放锁
//也不能把获取锁在try中进行，因为有可能在获取锁的时候抛出异常
 lock.ublock();
}
```

可重入锁

AbstractQueuedSynchronizer：抽象队列同步器

ReentrantLock内部有一个AQS对象

AQS对象内部有一个核心变量state，int类型，代表了加锁状态 初始值时，state = 0;

AQS内部还有一个核心变量，用来记录当前加锁的是哪个线程



线程1：加锁过程就是利用CAS操作将state变为1，当前线程变为线程1

线程2：加锁，发现state不为0，然后再查看是不是自己加的锁，发现不是，那么就加锁失败，线程2将自己放入AQS中的一个等待队列

当线程1释放锁后，从等待队列头获取一个线程进行加锁

# 六、Lock与synchronized关键字的区别

Lock 接口可以尝试非阻塞地获取锁 当前线程尝试获取锁。如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。
Lock 接口能被中断地获取锁 与 synchronized 不同，获取到锁的线程能够响应中断，当获取到的锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。

Lock 接口在指定的截止时间之前获取锁，如果截止时间到了依旧无法获取锁，则返回。



1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

5）Lock可以提高多个线程进行读操作的效率。

　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

# 七、wait与join的区别

join方法在调用wait方法后, 并没有执行notify方法, 这个是在jvm中实现的, 一个线程执行结束后会执行该线程自身对象的notifyAll方法