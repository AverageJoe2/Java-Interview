# 一、线程创建的方式

## 1.1 继承Thread类，重写run方法

## 1.2 实现Runable接口，重写run方法

## 1.3 使用匿名内部类

 使用实现实现Runnable接口好，原因实现了接口还可以继续继承，继承了类不能再继承。

# 二、线程分类

Java中有两种线程，一种是用户线程，另一种是守护线程。

用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止

守护线程当进程不存在或主线程停止，守护线程也会被停止。

使用setDaemon(true)方法设置为守护线程

# 三、线程运行状态

线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。

![](http://mycsdnblog.work/201919052036-q.png)

## 3.1 操作系统中的线程和Java线程状态的关系

从实际意义上来讲，操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：

- ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。
- running：表示线程获得了CPU使用权，正在进行运算
- waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用

**为什么除去new和terminated状态？是因为这两种状态实际上并不存在于线程运行中，所以也没什么实际讨论的意义。**

对于Java中的线程状态：

**无论是Timed Waiting ，Waiting还是Blocked，对应的都是操作系统线程的waiting（等待）状态。**

**而Runnable状态，则对应了操作系统中的ready和running状态。**

而对不同的操作系统，由于本身设计思路不一样，对于线程的设计也存在种种差异，所以JVM在设计上，就已经声明：

**虚拟机中的线程状态，不反应任何操作系统线程状态**

# 四、join()方法

当在主线程当中执行到t1.join()方法时，就认为主线程应该把执行权让给t1

# 五、线程优先级

在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。

**注意设置了优先级， 不代表每次都一定会被执行。 只是CPU调度会有限分配**

# 六、yield方法

Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）

yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。

结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

# 七、start和run的区别

**直接调用run方法是无法开启一个新线程的。start方法其实是在一个新的操作系统线程上面去调用run方法。换句话说，直接调用run方法而不是调用start方法的话，它并不会开启新的线程，而是在调用run的当前的线程当中执行你的操作。**