# 一、定义

位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。

# 二、数据结构

我们用一个具体的例子来讲解，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用BitMap的方法来达到排序的目的。要表示8个数，我们就只需要8个bit（1Bytes）。 
（1）首先我们开辟1字节（8bit）的空间，将这些空间的所有bit位都置为0，如下图：

![这里写图片描述](https://img-blog.csdn.net/20150207143647124)

（2）然后遍历这5个元素，首先第1个元素是4，那么就把4对应的位置为1,因为是从零开始的，所以要把第5个位置为1（如下图）：

![这里写图片描述](https://img-blog.csdn.net/20150207143740102)

然后再处理第2个元素7，将第8个位置为1,，接着再处理第3个元素，一直到处理完所有元素，将相应的位置为1，这时候的内存的bit位的状态如下：

![这里写图片描述](https://img-blog.csdn.net/20150207143819256)

（3）然后我们现在遍历一遍bit区域，将该位是1的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。

算法思想比较简单，但关键是如何确定十进制的数映射到二进制bit位的map图。

# 三、Map映射

假设需要排序或者查找的总数N=10000000。 

BitMap中1bit代表一个数字 

1个int = 4Bytes = 4*8bit = 32 bit,那么N个数需要N/32 int空间。所以我们需要申请内存空间的大小为int a[1 + N/32]，其中：a[0]在内存中占32为可以对应十进制数0-31，依次类推：

BitMap表为：

```
    a[0]  --------->  0-31 
    a[1]  --------->  32-63 
    a[2]  --------->  64-95 
    a[3]  --------->  96-127 
    .......... 
```

那么十进制数如何转换为对应的bit位，下面介绍用位移将十进制数转换为对应的bit位。

申请一个int一维数组，那么可以当作为列为32位的二维数组。

![](http://mycsdnblog.work/201919291535-S.png)

例如： 
十进制1 在a[0]中，位置如下图： 
![这里写图片描述](https://img-blog.csdn.net/20150207150658412)
十进制31 在a[0]中，位置如下图： 
![这里写图片描述](https://img-blog.csdn.net/20150207150846177)
十进制32 在a[1]中，位置如下图： 
![这里写图片描述](https://img-blog.csdn.net/20150207150937127)
十进制33 在a[1]中，位置如下图： 
![这里写图片描述](https://img-blog.csdn.net/20150207151111539)

通过上图分析得出通过以下几步将十进制数如何转换为对应的bit位：

**（1）求十进制数在对应数组a中的下标**

十进制数0-31，对应在数组a[0]中，32-63对应在数组a[1]中，64-95对应在数组a[2]中……… 

**分析得出：对于一个十进制数n,对应在数组a[n/32]中** 

例如n=11,那么 n/32=0，则11对应在数组a中的下标为0，n=32,那么n/32=1，则32对应在数组a中的下标为1，n = 106,那么n/32 = 3，则106对应数组a中的下标为3。

**（2）求十进制数在对应数组a[i]中的下标**

例如十进制数1在a[0]的下标为1，十进制数31在a[0]中下标为31，十进制数32在a[1]中下标为0。 
在十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得在对应数组a[i]中的下标。 
**分析得出：对于一个十进制数n,对应在数组`a[n/32]`中**

**（3）移位**

对于一个十进制数n,对应在数组`a[n/32][n%32]`中，但数组a毕竟不是一个二维数组，我们通过移位操作实现置1。 
a[n/32] |= 1 << n % 32 

移位操作：

a[n>>5] |= 1 << (n & 0x1F)

n & 0x1F 保留n的后五位 相当于 n % 32 求十进制数在数组a[i]中的下标

# 四、位图法的缺点

1. 可读性差
2. 位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。
3. 位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。

# 五、位图法的应用

1、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中。
　　首先，将这40亿个数字存储到bitmap中，然后对于给出的数，判断是否在bitmap中即可。

2、使用位图法判断整形数组是否存在重复

遍历数组，一个一个放入bitmap，并且检查其是否在bitmap中出现过，如果没出现放入，否则即为重复的元素。

3、使用位图法进行整形数组排序

首先遍历数组，得到数组的最大最小值，然后根据这个最大最小值来缩小bitmap的范围。这里需要注意对于int的负数，都要转化为unsigned int来处理，而且取位的时候，数字要减去最小值。

4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

参 考的一个方法是：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。其实，这里可以使用两个普 通的Bitmap，即第一个Bitmap存储的是整数是否出现，如果再次出现，则在第二个Bitmap中设置即可。这样的话，就可以使用简单的1- Bitmap了。

5、排序

6、快速去重

2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 

首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间几十兆左右。

接下来的任务就是遍历一次这2.5亿个数字，如果对应的状态位为00，则将其变为01；如果对应的状态位为01，则将其变为11；如果为11，,对应的转态位保持不变。

最后，我们将状态位为01的进行统计，就得到了不重复的数字个数，时间复杂度为O(n)。

7、快速查询

同样，我们利用Bit-map也可以进行快速查询，这种情况下对于一个数字只需要一个bit位就可以了，0表示不存在，1表示存在。假设上述的题目改为，如何快速判断一个数字是够存在于上述的2.5亿个数字集合中。

同之前一样，首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为1。遍历完以后就是查询，由于我们的Bit-map采取的是连续存储（整型数组形式，一个数组元素对应32bits），我们实际上是采用了一种分桶的思想。一个数组元素可以存储32个状态位，那将待查询的数字除以32，定位到对应的数组元素（桶），然后再求余（%32），就可以定位到相应的状态位。如果为1，则代表改数字存在；否则，该数字不存在。

8、布隆过滤器

当一个元素被加入集合中时,通过k个散列函数将这个元素映射成一个位数组中的k个点,并将这k个点全部置为1.

有一定的误判率--在判断一个元素是否属于某个集合时,有可能会把不属于这个集合的元素误判为属于这个集合.因此,它不适合那些"零误判"的应用场合.在能容忍低误判的应用场景下,布隆过滤器通过极少的误判换区了存储空间的极大节省.

Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注：如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。

**在判断y是否属于这个集合时，对y应用k次哈希函数，若所有hi(y)的位置都是1（1≤i≤k），就认为y是集合中的元素，否则就认为y不是集合中的元素。**

本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。

相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。