# 一、JWT

JWT全称JSON Web Token，由三部分组成header（头部，用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等）、payload（载荷，就是存放有效信息的地方，在这一部分中存放过期时间）和signature（签证，签证信息）。

# 二、Token过期刷新方案

1、单点登录

用户登录，后端验证用户成功之后生成两个token，这两个token分别是access_token（访问接口使用的token）、refresh_token（access_token过期后用于刷续期的token，注意设置refresh_token的过期时间需比access_token的过期时间长），后端将用户信息和这两个token存放到redis中并返回给前端。

前端在获取到登录成功返回的两个token之后，将之存放到localStorage本地存储中。

2、接口请求
前端封装统一接口请求函数、token刷新函数，在请求成功之后对返回结果进行校验，如果token过期，则调用token刷新函数请求新的token.

后端在接收到token刷新请求之后通过结合redis中存放的用户信息、token和refresh_token对请求参数进行验证，验证通过之后生成新的token和refresh_token存放到redis中并返回给前端。至此完成token刷新。

3、多请求应对

所谓多请求，就是指在短时间内同时发生多个请求，如果此时token已经过期，那么这些请求都会出现token过期请求失败的情况。

为了避免反复刷新token，需要设置一个刷新token的开关isRefresh，当一个请求出现token过期的时候，这个时候会调用token刷新函数，与此同时关闭开关将isRefresh的值设置为false，避免后续请求去调用token刷新函数。
当发现token过期时，咱们将请求延缓到token刷新之后再重新执行请求，这里采用Promise函数，把每一个token失效的请求都存到一个Promise函数集合里面，当token刷新之后打开开关将isRefresh的值设置为true，然后批量执行Promise函数集合里面的Promise函数，返回请求结果。

在后端使用RESTful APIs将应用程序迁移到HTML5时，我正在做相关的修修补补的工作。我想出的解决办法是：

1. 在成功登录后，客户端会发出会话时间为30分钟(或任何常用的服务器端会话时间)的令牌。
2. 创建一个客户端计时器来调用服务在其到期之前更新令牌。新的令牌将取代以后的调用。

如您所见，这样可以减少频繁更新令牌请求。如果用户在更新令牌调用触发之前关闭浏览器/应用程序，则先前的令牌将及时到期，用户将必须重新登录。

可以实现更复杂的策略来满足用户不活动时的情形(例如忽略打开的浏览器选项卡)。在这种情况下，续订令牌调用应包括预期到期时间，而这个时间不应超过定义的会话时间。那么应用程序必须相应地跟踪上一次用户的交互。

我不喜欢设置长期到期时间的思路，因为这种方法对于不需要那么频繁身份验证的本机应用程序可能无法正常工作。

# 三、Spring Security OAuth2

主要思路：

1. 首先用过期token访问受拦截资源
2. 认证失败返回401的时候调用异常处理器
3. 通过异常处理器结合refresh_token进行token的刷新
4. 刷新成功则通过请求转发（request.getRequestDispatcher）的方式再次访问受拦截资源

